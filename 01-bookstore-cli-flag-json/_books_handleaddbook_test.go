// ********RoostGPT********
/*
Test generated by RoostGPT for test Golang-Bookstore using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=handleAddBook_2643b4d800
ROOST_METHOD_SIG_HASH=handleAddBook_7ae19436dd

FUNCTION_DEF=func handleAddBook(addCmd *flag.FlagSet, id, title, author, price, image_url *string, addNewBook bool)
Scenario 1: Normal operation - Adding a new book
Details:
    Description: This test is meant to check the functionality of adding a new book to the bookstore.
Execution:
    Arrange: Create a new book with all required details (id, title, author, price, image_url). Set addNewBook to true.
    Act: Invoke the function with the new book and addNewBook flag.
    Assert: Verify that the new book has been added to the bookstore.
Validation:
    The assertion is checking if the new book is added successfully. This is important as it verifies the basic functionality of adding a new book to the bookstore.

Scenario 2: Normal operation - Updating an existing book
Details:
    Description: This test is meant to check the functionality of updating an existing book in the bookstore.
Execution:
    Arrange: Create a book with an existing id but with new details (title, author, price, image_url). Set addNewBook to false.
    Act: Invoke the function with the updated book and addNewBook flag.
    Assert: Verify that the book in the bookstore is updated with the new details.
Validation:
    The assertion is checking if the existing book is updated successfully. This is important as it verifies the basic functionality of updating an existing book in the bookstore.

Scenario 3: Edge case - Adding a book with missing details
Details:
    Description: This test is meant to check the error handling when adding a new book with missing details.
Execution:
    Arrange: Create a new book with missing details (id, title, author, price, image_url). Set addNewBook to true.
    Act: Invoke the function with the new book and addNewBook flag.
    Assert: Verify that an error message is printed and the program exits with code 1.
Validation:
    The assertion is checking if the program handles the error correctly when trying to add a book with missing details. This is important as it prevents the addition of incomplete books to the bookstore.

Scenario 4: Edge case - Updating a non-existing book
Details:
    Description: This test is meant to check the error handling when updating a non-existing book in the bookstore.
Execution:
    Arrange: Create a book with a non-existing id. Set addNewBook to false.
    Act: Invoke the function with the non-existing book and addNewBook flag.
    Assert: Verify that an error message is printed and the program exits with code 1.
Validation:
    The assertion is checking if the program handles the error correctly when trying to update a non-existing book. This is important as it prevents update operations on non-existing books in the bookstore.
*/

// ********RoostGPT********
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"testing"
)

type Book struct {
	Id       string `json:"id"`
	Title    string `json:"title"`
	Author   string `json:"author"`
	Price    string `json:"price"`
	Imageurl string `json:"image_url"`
}

func TestHandleAddBook(t *testing.T) {
	type test struct {
		name       string
		id         string
		title      string
		author     string
		price      string
		image_url  string
		addNewBook bool
		wantExit   bool
		wantErr    bool
		wantOutput string
	}

	tests := []test{
		{name: "Normal operation - Adding a new book", id: "1", title: "Go Programming", author: "John Doe", price: "50", image_url: "http://example.com", addNewBook: true, wantExit: false, wantErr: false, wantOutput: "Book added successfully"},
		{name: "Normal operation - Updating an existing book", id: "1", title: "Advanced Go Programming", author: "John Doe", price: "70", image_url: "http://example.com", addNewBook: false, wantExit: false, wantErr: false, wantOutput: "Book added successfully"},
		{name: "Edge case - Adding a book with missing details", id: "", title: "", author: "", price: "", image_url: "", addNewBook: true, wantExit: true, wantErr: false, wantOutput: "Please provide book id, title, author,price"},
		{name: "Edge case - Updating a non-existing book", id: "3", title: "Non-existing book", author: "Non-existing author", price: "0", image_url: "http://non-existing.com", addNewBook: false, wantExit: true, wantErr: false, wantOutput: "Book not found"},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			r, w, _ := os.Pipe()
			os.Stdout = w

			os.Args = []string{"cmd", "add", tc.id, tc.title, tc.author, tc.price, tc.image_url}

			addCmd := flag.NewFlagSet("add", flag.ExitOnError)

			id := addCmd.String("id", "", "Book ID")
			title := addCmd.String("title", "", "Book title")
			author := addCmd.String("author", "", "Book author")
			price := addCmd.String("price", "", "Book price")
			image_url := addCmd.String("image_url", "", "Book image URL")

			handleAddBook(addCmd, id, title, author, price, image_url, tc.addNewBook)

			w.Close()
			out, _ := ioutil.ReadAll(r)
			os.Stdout = os.Stderr

			if !strings.Contains(string(out), tc.wantOutput) {
				t.Errorf("unexpected output: got %v, want %v", string(out), tc.wantOutput)
			}
		})
	}
}

func handleAddBook(addCmd *flag.FlagSet, id, title, author, price, image_url *string, addNewBook bool) {
	addCmd.Parse(os.Args[2:])

	if *id == "" || *title == "" || *author == "" || *price == "" || *image_url == "" {
		fmt.Println("Please provide book id, title, author,price")
		addCmd.PrintDefaults()
		os.Exit(1)
	}

	books := getBooks()
	var newBook Book

	var foundBook bool

	if addNewBook {
		newBook = Book{*id, *title, *author, *price, *image_url}
		books = append(books, newBook)
	} else {
		for i, book := range books {
			if book.Id == *id {
				books[i] = Book{*id, *title, *author, *price, *image_url}
				foundBook = true
			}
		}

		if !foundBook {
			fmt.Println("Book not found")
			os.Exit(1)
		}
	}

	err := saveBooks(books)

	checkError(err)

	fmt.Println("Book added successfully")

}

func getBooks() (books []Book) {
	booksBytes, err := ioutil.ReadFile("./books.json")
	checkError(err)

	err = json.Unmarshal(booksBytes, &books)
	checkError(err)

	return books

}

func saveBooks(books []Book) error {
	booksBytes, err := json.Marshal(books)
	checkError(err)

	err = ioutil.WriteFile("./books.json", booksBytes, 0644)

	return err
}

func checkError(err error) {
	if err != nil {
		fmt.Println("Error Happened ", err)
		os.Exit(1)
	}

}
