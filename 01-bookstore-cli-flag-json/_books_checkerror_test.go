// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-bookstore using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=checkError_e75f941bf5
ROOST_METHOD_SIG_HASH=checkError_e49b9fc736

FUNCTION_DEF=func checkError(err error)
```
Scenario 1: No Error Occurred

Details:
  Description: This test is meant to check the function when no error has occurred. The function should not print anything and should not cause the program to exit.
Execution:
  Arrange: No setup is required as no error is being passed to the function.
  Act: Invoke the checkError function with a nil error.
  Assert: Use Go testing facilities to verify that the function does not print anything and does not cause the program to exit.
Validation:
  The choice of assertion is based on the function's behavior when no error is passed to it. It is important to test this scenario to ensure that the function behaves correctly when no error occurs, as this is the expected behavior in most cases.

Scenario 2: An Error Occurred

Details:
  Description: This test is meant to check the function when an error has occurred. The function should print the error message and exit the program.
Execution:
  Arrange: Create a new error using the errors package.
  Act: Invoke the checkError function with the created error.
  Assert: Use Go testing facilities to verify that the function prints the error message and causes the program to exit.
Validation:
  The choice of assertion is based on the function's behavior when an error is passed to it. It is important to test this scenario to ensure that the function behaves correctly when an error occurs, as this is the expected behavior in case of an error.

Scenario 3: A Custom Error Occurred

Details:
  Description: This test is meant to check the function when a custom error has occurred. The function should print the custom error message and exit the program.
Execution:
  Arrange: Create a new custom error using the errors package.
  Act: Invoke the checkError function with the created custom error.
  Assert: Use Go testing facilities to verify that the function prints the custom error message and causes the program to exit.
Validation:
  The choice of assertion is based on the function's behavior when a custom error is passed to it. It is important to test this scenario to ensure that the function behaves correctly when a custom error occurs. This is especially important in applications where custom errors are used to provide more information about the error to the user.
```
*/

// ********RoostGPT********
package bookstore

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"testing"
)

func checkError(err error) {
	if err != nil {
		fmt.Println("Error Happened ", err)
		os.Exit(1)
	}
}

func TestCheckError(t *testing.T) {
	// Define test cases
	testCases := []struct {
		name        string
		err         error
		expectedOut string
	}{
		{
			name:        "No Error Occurred",
			err:         nil,
			expectedOut: "",
		},
		{
			name:        "An Error Occurred",
			err:         errors.New("a standard error occurred"),
			expectedOut: "Error Happened a standard error occurred\n",
		},
		{
			name:        "A Custom Error Occurred",
			err:         errors.New("a custom error occurred"),
			expectedOut: "Error Happened a custom error occurred\n",
		},
	}

	// Iterate through test cases
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Capture stdout
			oldStdout := os.Stdout
			r, w, _ := os.Pipe()
			os.Stdout = w

			// Act
			if os.Getenv("BE_CRASHER") == "1" {
				checkError(tc.err)
				return
			}
			cmd := exec.Command(os.Args[0], "-test.run=TestCheckError")
			cmd.Env = append(os.Environ(), "BE_CRASHER=1")
			err := cmd.Run()

			// Close and restore stdout
			w.Close()
			os.Stdout = oldStdout

			// Assert
			if e, ok := err.(*exec.ExitError); ok && !e.Success() {
				out, _ := ioutil.ReadAll(r)
				if string(out) != tc.expectedOut {
					t.Fatalf("Expected output %q but got %q", tc.expectedOut, out)
				}
			} else if tc.err != nil {
				t.Fatal("Process ran with err nil, want exit status 1")
			}
		})
	}
}
