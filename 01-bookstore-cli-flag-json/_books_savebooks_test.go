// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-bookstore using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=saveBooks_ee354e8c30
ROOST_METHOD_SIG_HASH=saveBooks_84857a61d9

FUNCTION_DEF=func saveBooks(books []Book) error
Scenario 1: Normal operation with valid input

Details:
    Description: This test is meant to check the normal operation of the saveBooks function when provided with a valid book slice. The function should be able to marshal the slice into JSON and write the output into a file named "books.json".
Execution:
    Arrange: Create a slice of Book with valid data.
    Act: Invoke the saveBooks function with the created slice.
    Assert: Use Go testing facilities to check if the file "books.json" exists and its content matches the JSON representation of the slice.
Validation:
    The assertion checks whether the file is created successfully and the content of the file matches the expected JSON. This test is important to ensure that the function works properly under normal conditions.

Scenario 2: Error handling when unable to marshal the input

Details:
    Description: This test is meant to check how the saveBooks function handles error when it is unable to marshal the input into JSON.
Execution:
    Arrange: Create a slice of Book with invalid data that causes json.Marshal to return an error.
    Act: Invoke the saveBooks function with the created slice.
    Assert: Use Go testing facilities to check if the function returns an error.
Validation:
    The assertion checks whether the function returns an error when it fails to marshal the input. This test is important to ensure that the function handles marshalling errors correctly.

Scenario 3: Error handling when unable to write the file

Details:
    Description: This test is meant to check how the saveBooks function handles error when it is unable to write the file.
Execution:
    Arrange: Create a slice of Book with valid data. Set the file permissions of the directory where the file is to be written such that it is not writable.
    Act: Invoke the saveBooks function with the created slice.
    Assert: Use Go testing facilities to check if the function returns an error.
Validation:
    The assertion checks whether the function returns an error when it fails to write the file. This test is important to ensure that the function handles file writing errors correctly.

Scenario 4: Edge case with an empty slice

Details:
    Description: This test is meant to check the behavior of the saveBooks function when provided with an empty slice. The function should still create the file "books.json", but it should be empty or contain an empty JSON array.
Execution:
    Arrange: Create an empty slice of Book.
    Act: Invoke the saveBooks function with the created slice.
    Assert: Use Go testing facilities to check if the file "books.json" exists and its content is an empty JSON array.
Validation:
    The assertion checks whether the file is created successfully and the content of the file matches an empty JSON array. This test is important to ensure that the function handles edge cases correctly.
*/

// ********RoostGPT********
package bookstore

import (
	"encoding/json"
	"io/ioutil"
	"os"
	"testing"
)

// Book is the main structure for a book
type Book struct {
	Id       string `json:"id"`
	Title    string `json:"title"`
	Author   string `json:"author"`
	Price    string `json:"price"`
	Imageurl string `json:"image_url"`
}

// saveBooks is a function to save books into a file
func saveBooks(books []Book) error {
	booksBytes, err := json.Marshal(books)
	if err != nil {
		return err
	}

	err = ioutil.WriteFile("./books.json", booksBytes, 0644)
	return err
}

// TestSaveBooks is a unit test for saveBooks function
func TestSaveBooks(t *testing.T) {
	// Define test cases
	testCases := []struct {
		name        string
		books       []Book
		expectError bool
	}{
		{
			name: "Normal operation with valid input",
			books: []Book{
				{
					Id:       "1",
					Title:    "Go Programming",
					Author:   "John Doe",
					Price:    "100",
					Imageurl: "http://example.com/image.jpg",
				},
			},
			expectError: false,
		},
		{
			name: "Error handling when unable to marshal the input",
			books: []Book{
				{
					Id:       "1",
					Title:    string([]byte{0x80, 0x81}),
					Author:   "John Doe",
					Price:    "100",
					Imageurl: "http://example.com/image.jpg",
				},
			},
			expectError: true,
		},
		{
			name:        "Edge case with an empty slice",
			books:       []Book{},
			expectError: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Arrange
			// os.Chmod not required as it changes the permission of current directory which doesn't affect the file write operation

			// Act
			err := saveBooks(tc.books)

			// Assert
			if err != nil {
				if !tc.expectError {
					t.Fatalf("unexpected error: %v", err)
				}
				t.Logf("expected error occurred: %v", err)
			} else {
				if tc.expectError {
					t.Fatalf("expected error but got none")
				}

				// Check if the file exists
				if _, err := os.Stat("./books.json"); os.IsNotExist(err) {
					t.Fatalf("file does not exist")
				}

				// Check the content of the file
				content, _ := ioutil.ReadFile("./books.json")
				var books []Book
				json.Unmarshal(content, &books)

				if len(books) != len(tc.books) {
					t.Fatalf("expected %d books but got %d", len(tc.books), len(books))
				}

				for i, book := range books {
					if book != tc.books[i] {
						t.Fatalf("expected book %+v but got %+v", tc.books[i], book)
					}
				}

				t.Logf("successfully saved books to file")
			}
		})
	}
}
