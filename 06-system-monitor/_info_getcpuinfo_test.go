// ********RoostGPT********
/*
Test generated by RoostGPT for test SystemMonitor using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=getCpuInfo_dbc8eaac65
ROOST_METHOD_SIG_HASH=getCpuInfo_5e7f7ebe6c

FUNCTION_DEF=func getCpuInfo() (int, float64)
Based on the provided function and context, here are several test scenarios for the `getCpuInfo()` function:

Scenario 1: Verify Correct Number of CPU Cores

Details:
  Description: This test ensures that the function returns the correct number of CPU cores for the system it's running on.
Execution:
  Arrange: No specific arrangement needed as the function directly uses the system's information.
  Act: Call getCpuInfo() and store the returned values.
  Assert: Compare the returned number of cores with the actual number of cores on the system.
Validation:
  The assertion should verify that the returned number of cores matches the system's actual core count. This test is crucial to ensure the function accurately reports system specifications.

Scenario 2: Check CPU Percentage Range

Details:
  Description: Verify that the returned CPU percentage is within the valid range (0-100%).
Execution:
  Arrange: No specific arrangement needed.
  Act: Call getCpuInfo() and store the returned values.
  Assert: Check if the returned CPU percentage is between 0 and 100.
Validation:
  This test ensures that the function returns a valid CPU usage percentage. It's important for monitoring applications to provide accurate and meaningful data.

Scenario 3: Consistency of Multiple Calls

Details:
  Description: Test if multiple consecutive calls to getCpuInfo() return consistent results.
Execution:
  Arrange: Prepare to make multiple calls to the function.
  Act: Call getCpuInfo() multiple times in quick succession.
  Assert: Compare the results of these calls for consistency in core count and reasonable variation in CPU percentage.
Validation:
  This test checks the function's reliability and stability. The core count should remain constant, while CPU percentage may vary slightly but should show a consistent trend.

Scenario 4: Performance Under Load

Details:
  Description: Test the function's behavior when the system is under high CPU load.
Execution:
  Arrange: Set up a process that consumes significant CPU resources.
  Act: Call getCpuInfo() while the system is under load.
  Assert: Verify that the returned CPU percentage reflects the high usage.
Validation:
  This scenario tests the function's accuracy under stress conditions, ensuring it can correctly report high CPU usage when the system is under load.

Scenario 5: Behavior with Mock CPU Info

Details:
  Description: Use mocked CPU information to test the function's behavior with predefined values.
Execution:
  Arrange: Set up mocks for the cpu.Counts() and cpu.Percent() functions to return known values.
  Act: Call getCpuInfo() with the mocked environment.
  Assert: Verify that the function returns the exact values provided by the mocks.
Validation:
  This test ensures that the function correctly processes and returns the information provided by the underlying system calls, isolating its logic from actual system variabilities.

Scenario 6: Error Handling for cpu.Counts()

Details:
  Description: Test how the function handles errors from cpu.Counts().
Execution:
  Arrange: Mock cpu.Counts() to return an error.
  Act: Call getCpuInfo().
  Assert: Check if the function handles the error gracefully and returns an appropriate value for the core count.
Validation:
  This test is important to ensure the function's robustness in case of system call failures, maintaining application stability.

Scenario 7: Error Handling for cpu.Percent()

Details:
  Description: Verify the function's behavior when cpu.Percent() returns an error.
Execution:
  Arrange: Mock cpu.Percent() to return an error.
  Act: Call getCpuInfo().
  Assert: Verify that the function handles the error appropriately and returns a valid CPU percentage value.
Validation:
  This scenario tests the error handling capabilities of the function, ensuring it degrades gracefully when unable to retrieve CPU usage data.

These scenarios cover various aspects of the getCpuInfo() function, including normal operation, edge cases, and error handling. They aim to ensure the function's reliability, accuracy, and robustness in different situations.
*/

// ********RoostGPT********
package main

import (
	"errors"
	"testing"
	"time"

	"github.com/shirou/gopsutil/cpu"
)

// MockCPU is a mock implementation of the cpu package functions
type MockCPU struct {
	mockCounts  func(bool) (int, error)
	mockPercent func(time.Duration, bool) ([]float64, error)
}

func (m *MockCPU) Counts(logical bool) (int, error) {
	return m.mockCounts(logical)
}

func (m *MockCPU) Percent(interval time.Duration, percpu bool) ([]float64, error) {
	return m.mockPercent(interval, percpu)
}

func TestGetCpuInfo(t *testing.T) {
	originalCPUCounts := cpu.Counts
	originalCPUPercent := cpu.Percent
	defer func() {
		cpu.Counts = originalCPUCounts
		cpu.Percent = originalCPUPercent
	}()

	tests := []struct {
		name           string
		mockCounts     func(bool) (int, error)
		mockPercent    func(time.Duration, bool) ([]float64, error)
		expectedCores  int
		expectedUsage  float64
		expectingError bool
	}{
		{
			name: "Correct Number of CPU Cores",
			mockCounts: func(bool) (int, error) {
				return 4, nil
			},
			mockPercent: func(time.Duration, bool) ([]float64, error) {
				return []float64{50.0}, nil
			},
			expectedCores: 4,
			expectedUsage: 50.0,
		},
		{
			name: "CPU Percentage Range",
			mockCounts: func(bool) (int, error) {
				return 2, nil
			},
			mockPercent: func(time.Duration, bool) ([]float64, error) {
				return []float64{75.5}, nil
			},
			expectedCores: 2,
			expectedUsage: 75.5,
		},
		{
			name: "Consistency of Multiple Calls",
			mockCounts: func(bool) (int, error) {
				return 8, nil
			},
			mockPercent: func(time.Duration, bool) ([]float64, error) {
				return []float64{60.0}, nil
			},
			expectedCores: 8,
			expectedUsage: 60.0,
		},
		{
			name: "Performance Under Load",
			mockCounts: func(bool) (int, error) {
				return 16, nil
			},
			mockPercent: func(time.Duration, bool) ([]float64, error) {
				return []float64{95.5}, nil
			},
			expectedCores: 16,
			expectedUsage: 95.5,
		},
		{
			name: "Behavior with Mock CPU Info",
			mockCounts: func(bool) (int, error) {
				return 32, nil
			},
			mockPercent: func(time.Duration, bool) ([]float64, error) {
				return []float64{25.5}, nil
			},
			expectedCores: 32,
			expectedUsage: 25.5,
		},
		{
			name: "Error Handling for cpu.Counts()",
			mockCounts: func(bool) (int, error) {
				return 0, errors.New("cpu count error")
			},
			mockPercent: func(time.Duration, bool) ([]float64, error) {
				return []float64{50.0}, nil
			},
			expectedCores:  0,
			expectedUsage:  0,
			expectingError: true,
		},
		{
			name: "Error Handling for cpu.Percent()",
			mockCounts: func(bool) (int, error) {
				return 4, nil
			},
			mockPercent: func(time.Duration, bool) ([]float64, error) {
				return nil, errors.New("cpu percent error")
			},
			expectedCores:  4,
			expectedUsage:  0,
			expectingError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockCPU := &MockCPU{
				mockCounts:  tt.mockCounts,
				mockPercent: tt.mockPercent,
			}

			cpu.Counts = mockCPU.Counts
			cpu.Percent = mockCPU.Percent

			cores, usage := getCpuInfo()

			if tt.expectingError {
				if cores != 0 || usage != 0 {
					t.Errorf("Expected error, but got cores: %d, usage: %.2f", cores, usage)
				}
			} else {
				if cores != tt.expectedCores {
					t.Errorf("Expected %d cores, but got %d", tt.expectedCores, cores)
				}

				if usage != tt.expectedUsage {
					t.Errorf("Expected %.2f%% usage, but got %.2f%%", tt.expectedUsage, usage)
				}
			}
		})
	}
}
